/**
 * ðŸ¦Ž Zynx Go Type Generator
 * 
 * Generates Go struct definitions from DBML schemas
 */

import { TypeGenerator, CommonTypeMappings } from "./base.ts";
import type { DatabaseSchema, DBMLTable, DBMLField, DBMLRef } from "../../types.ts";

export class GoGenerator extends TypeGenerator {
  readonly language = "golang";
  readonly fileExtension = ".go";

  constructor(config: any = {}) {
    super({
      caseStyle: "PascalCase", // Go convention
      ...config
    });
  }

  override getImports(schema: DatabaseSchema): string[] {
    const imports = new Set<string>();
    
    // Check for time.Time usage
    const hasTimeFields = schema.tables.some(table => 
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["timestamp", "timestamptz", "date", "datetime"].includes(baseType);
      })
    );
    
    if (hasTimeFields) {
      imports.add("time");
    }
    
    // Check for UUID usage
    const hasUUIDFields = schema.tables.some(table =>
      table.fields.some(field => this.getBaseType(field.type) === "uuid")
    );
    
    if (hasUUIDFields) {
      imports.add("github.com/google/uuid");
    }
    
    // Check for JSON usage
    const hasJSONFields = schema.tables.some(table =>
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["json", "jsonb"].includes(baseType);
      })
    );
    
    if (hasJSONFields) {
      imports.add("encoding/json");
    }
    
    // Format imports
    const importLines: string[] = [];
    if (imports.size > 0) {
      importLines.push("import (");
      for (const imp of Array.from(imports).sort()) {
        if (imp.includes("/")) {
          importLines.push(`\t"${imp}"`);
        } else {
          importLines.push(`\t"${imp}"`);
        }
      }
      importLines.push(")");
    }
    
    return importLines;
  }

  override getFileHeader(schema: DatabaseSchema): string {
    const header = [
      "// Generated by Zynx - Database Type Definitions",
      `// Generated at: ${new Date().toISOString()}`,
      "",
      `package ${this.config.namespace || "models"}`,
      ""
    ];

    return header.join("\n");
  }

  generateSchema(schema: DatabaseSchema): string {
    const types: string[] = [];
    
    // Generate structs for each table
    for (const table of schema.tables) {
      types.push(this.generateTable(table));
    }

    // Generate custom type definitions
    const customTypes = this.generateCustomTypes(schema);
    if (customTypes.length > 0) {
      types.unshift(...customTypes);
    }

    return types.join("\n\n");
  }

  generateTable(table: DBMLTable): string {
    const structName = this.toPascalCase(table.name);
    const lines: string[] = [];

    // Add struct comment
    if (table.note && this.config.addComments) {
      lines.push(`// ${structName} ${table.note}`);
    } else {
      lines.push(`// ${structName} represents the ${table.name} table`);
    }

    lines.push(`type ${structName} struct {`);

    // Generate fields
    const maxNameLength = Math.max(...table.fields.map(f => this.toPascalCase(f.name).length));
    const maxTypeLength = Math.max(...table.fields.map(f => this.getGoType(f).length));

    for (const field of table.fields) {
      const fieldDef = this.generateFieldWithAlignment(field, table, maxNameLength, maxTypeLength);
      if (fieldDef) {
        lines.push(fieldDef);
      }
    }

    lines.push(`}`);

    // Generate enum types for fields
    const enumTypes = this.generateTableEnums(table);
    if (enumTypes.length > 0) {
      lines.push("");
      lines.push(...enumTypes);
    }

    return lines.join("\n");
  }

  generateField(field: DBMLField, table: DBMLTable): string {
    return this.generateFieldWithAlignment(field, table, 0, 0);
  }
  
  private generateFieldWithAlignment(field: DBMLField, table: DBMLTable, nameLength: number, typeLength: number): string {
    const fieldName = this.toPascalCase(field.name);
    const fieldType = this.getGoType(field);
    const jsonTag = this.getJSONTag(field);
    const dbTag = this.getDBTag(field);
    
    // Build tags
    const tags: string[] = [];
    if (jsonTag) tags.push(jsonTag);
    if (dbTag) tags.push(dbTag);
    
    const tagString = tags.length > 0 ? ` \`${tags.join(" ")}\`` : "";
    
    // Add padding for alignment
    const namePadding = " ".repeat(nameLength - fieldName.length);
    const typePadding = " ".repeat(typeLength - fieldType.length);
    
    // Add field comment inline if available
    const comment = field.note && this.config.addComments ? ` // ${field.note}` : "";
    
    return `\t${fieldName}${namePadding} ${fieldType}${typePadding}${tagString}${comment}`;
  }

  private getGoType(field: DBMLField): string {
    const goType = this.mapDBMLType(field.type, field);
    
    // Handle nullable fields with pointers
    if (this.isNullable(field) && !this.isSliceType(goType)) {
      return `*${goType}`;
    }
    
    return goType;
  }

  mapDBMLType(dbmlType: string, field: DBMLField): string {
    const baseType = this.getBaseType(dbmlType);
    const isArray = this.isArrayType(dbmlType);
    
    // Check for enum values
    const enumValues = this.extractEnumValues(dbmlType);
    if (enumValues) {
      const enumName = `${this.toPascalCase(field.name)}Type`;
      return isArray ? `[]${enumName}` : enumName;
    }

    // Check custom type mappings
    if (this.config.customTypes?.[baseType]) {
      const mappedType = this.config.customTypes[baseType];
      return isArray ? `[]${mappedType}` : mappedType;
    }

    // Use common type mappings
    const mapping = CommonTypeMappings[baseType];
    if (mapping) {
      const goType = mapping.go;
      
      // Special handling for interface{} in arrays
      if (goType === "interface{}" && isArray) {
        return "[]interface{}";
      }
      
      return isArray ? `[]${goType}` : goType;
    }

    // Default to string for unknown types
    console.warn(`Unknown DBML type: ${dbmlType}, defaulting to 'string'`);
    return isArray ? "[]string" : "string";
  }

  generateEnum(name: string, values: string[]): string {
    const typeName = this.toPascalCase(name);
    const lines: string[] = [];
    
    // Create type alias
    lines.push(`// ${typeName} represents allowed values for ${name}`);
    lines.push(`type ${typeName} string`);
    lines.push("");
    
    // Create constants
    lines.push("const (");
    for (const value of values) {
      const constName = `${typeName}${this.toPascalCase(value)}`;
      lines.push(`\t${constName} ${typeName} = "${value}"`);
    }
    lines.push(")");
    
    // Add validation method
    lines.push("");
    lines.push(`// Valid returns true if the ${typeName} is valid`);
    lines.push(`func (t ${typeName}) Valid() bool {`);
    lines.push(`\tswitch t {`);
    lines.push(`\tcase ${values.map(v => `${typeName}${this.toPascalCase(v)}`).join(", ")}:`);
    lines.push(`\t\treturn true`);
    lines.push(`\t}`);
    lines.push(`\treturn false`);
    lines.push(`}`);
    
    return lines.join("\n");
  }

  private generateTableEnums(table: DBMLTable): string[] {
    const enums: string[] = [];
    
    for (const field of table.fields) {
      const enumValues = this.extractEnumValues(field.type);
      if (enumValues) {
        const enumName = `${field.name}Type`;
        enums.push(this.generateEnum(enumName, enumValues));
      }
    }
    
    return enums;
  }

  private generateCustomTypes(schema: DatabaseSchema): string[] {
    const types: string[] = [];
    
    // Add common type aliases if needed
    const hasJSONFields = schema.tables.some(table =>
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["json", "jsonb"].includes(baseType);
      })
    );
    
    if (hasJSONFields) {
      types.push("// JSON represents a JSON value");
      types.push("type JSON = interface{}");
    }
    
    return types;
  }

  private getJSONTag(field: DBMLField): string {
    const jsonName = this.toSnakeCase(field.name);
    const omitempty = this.isNullable(field) ? ",omitempty" : "";
    return `json:"${jsonName}${omitempty}"`;
  }

  private getDBTag(field: DBMLField): string {
    const dbName = field.name;
    const constraints: string[] = [];
    
    if (field.pk) constraints.push("primarykey");
    if (field.unique) constraints.push("unique");
    if (field.not_null) constraints.push("not null");
    
    const constraintStr = constraints.length > 0 ? `;${constraints.join(";")}` : "";
    return `db:"${dbName}${constraintStr}"`;
  }

  private isSliceType(goType: string): boolean {
    return goType.startsWith("[]");
  }

  private toSnakeCase(str: string): string {
    return str.replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
  }
}