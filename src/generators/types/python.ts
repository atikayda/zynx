/**
 * ðŸ¦Ž Zynx Python Type Generator
 * 
 * Generates Python type definitions (dataclasses/TypedDict) from DBML schemas
 */

import { TypeGenerator, CommonTypeMappings } from "./base.ts";
import type { DatabaseSchema, DBMLTable, DBMLField, DBMLRef } from "../../types.ts";

export class PythonGenerator extends TypeGenerator {
  readonly language = "python";
  readonly fileExtension = ".py";
  
  private pythonStyle: "dataclass" | "typeddict" | "pydantic";

  constructor(config: any = {}) {
    super({
      caseStyle: "snake_case", // Python convention
      ...config
    });
    this.pythonStyle = config.pythonStyle || "dataclass";
  }

  override getImports(schema: DatabaseSchema): string[] {
    const imports: string[] = [];
    const typingImports = new Set<string>();
    
    // Add base imports based on style
    if (this.pythonStyle === "dataclass") {
      imports.push("from dataclasses import dataclass, field");
      imports.push("from typing import Optional, List, Dict, Any, Union");
    } else if (this.pythonStyle === "typeddict") {
      imports.push("from typing import TypedDict, Optional, List, Dict, Any, Union");
    } else if (this.pythonStyle === "pydantic") {
      imports.push("from pydantic import BaseModel, Field");
      imports.push("from typing import Optional, List, Dict, Any, Union");
    }
    
    // Check for datetime usage
    const hasDateTimeFields = schema.tables.some(table => 
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["timestamp", "timestamptz", "datetime"].includes(baseType);
      })
    );
    
    const hasDateFields = schema.tables.some(table =>
      table.fields.some(field => this.getBaseType(field.type) === "date")
    );
    
    const hasTimeFields = schema.tables.some(table =>
      table.fields.some(field => this.getBaseType(field.type) === "time")
    );
    
    if (hasDateTimeFields || hasDateFields || hasTimeFields) {
      imports.push("from datetime import datetime");
      if (hasDateFields) typingImports.add("date");
      if (hasTimeFields) typingImports.add("time");
    }
    
    // Check for UUID usage
    const hasUUIDFields = schema.tables.some(table =>
      table.fields.some(field => this.getBaseType(field.type) === "uuid")
    );
    
    if (hasUUIDFields) {
      imports.push("from uuid import UUID");
    }
    
    // Check for Decimal usage
    const hasDecimalFields = schema.tables.some(table =>
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["decimal", "numeric"].includes(baseType);
      })
    );
    
    if (hasDecimalFields) {
      imports.push("from decimal import Decimal");
    }
    
    // Add additional datetime imports if needed
    if (typingImports.size > 0) {
      const existingDatetime = imports.findIndex(imp => imp.startsWith("from datetime import"));
      if (existingDatetime >= 0) {
        imports[existingDatetime] = `from datetime import datetime${typingImports.size > 0 ? ", " + Array.from(typingImports).join(", ") : ""}`;
      }
    }
    
    // Check for enum usage
    const hasEnums = schema.tables.some(table =>
      table.fields.some(field => this.extractEnumValues(field.type))
    );
    
    if (hasEnums && this.config.enumStyle === "enum") {
      imports.push("from enum import Enum");
    }
    
    return imports;
  }

  override getFileHeader(schema: DatabaseSchema): string {
    const header = [
      '"""',
      "Generated by Zynx - Database Type Definitions",
      `Generated at: ${new Date().toISOString()}`,
      '"""',
      ""
    ];

    return header.join("\n");
  }

  generateSchema(schema: DatabaseSchema): string {
    const types: string[] = [];
    
    // Generate enums first if using enum style
    if (this.config.enumStyle === "enum") {
      const allEnums = this.generateAllEnums(schema);
      if (allEnums.length > 0) {
        types.push(...allEnums);
        types.push(""); // Empty line separator
      }
    }
    
    // Generate classes for each table
    for (const table of schema.tables) {
      types.push(this.generateTable(table));
    }

    return types.join("\n\n");
  }

  generateTable(table: DBMLTable): string {
    const className = this.toPascalCase(table.name);
    
    switch (this.pythonStyle) {
      case "dataclass":
        return this.generateDataclass(table, className);
      case "typeddict":
        return this.generateTypedDict(table, className);
      case "pydantic":
        return this.generatePydantic(table, className);
      default:
        return this.generateDataclass(table, className);
    }
  }

  private generateDataclass(table: DBMLTable, className: string): string {
    const lines: string[] = [];
    
    // Add class docstring
    if (table.note && this.config.addComments) {
      lines.push(`@dataclass`);
      lines.push(`class ${className}:`);
      lines.push(`    """${table.note}"""`);
    } else {
      lines.push(`@dataclass`);
      lines.push(`class ${className}:`);
      lines.push(`    """Represents the ${table.name} table"""`);
    }
    
    // Generate fields
    for (const field of table.fields) {
      const fieldDef = this.generateDataclassField(field, table);
      if (fieldDef) {
        lines.push(fieldDef);
      }
    }
    
    // Handle empty class
    if (table.fields.length === 0) {
      lines.push("    pass");
    }
    
    return lines.join("\n");
  }

  private generateTypedDict(table: DBMLTable, className: string): string {
    const lines: string[] = [];
    
    // Add class docstring
    if (table.note && this.config.addComments) {
      lines.push(`class ${className}(TypedDict):`);
      lines.push(`    """${table.note}"""`);
    } else {
      lines.push(`class ${className}(TypedDict):`);
      lines.push(`    """Represents the ${table.name} table"""`);
    }
    
    // Generate fields
    for (const field of table.fields) {
      const fieldDef = this.generateTypedDictField(field, table);
      if (fieldDef) {
        lines.push(fieldDef);
      }
    }
    
    // Handle empty class
    if (table.fields.length === 0) {
      lines.push("    pass");
    }
    
    return lines.join("\n");
  }

  private generatePydantic(table: DBMLTable, className: string): string {
    const lines: string[] = [];
    
    // Add class docstring
    if (table.note && this.config.addComments) {
      lines.push(`class ${className}(BaseModel):`);
      lines.push(`    """${table.note}"""`);
    } else {
      lines.push(`class ${className}(BaseModel):`);
      lines.push(`    """Represents the ${table.name} table"""`);
    }
    
    // Generate fields
    for (const field of table.fields) {
      const fieldDef = this.generatePydanticField(field, table);
      if (fieldDef) {
        lines.push(fieldDef);
      }
    }
    
    // Handle empty class
    if (table.fields.length === 0) {
      lines.push("    pass");
    }
    
    // Add Pydantic config
    lines.push("");
    lines.push("    class Config:");
    lines.push("        orm_mode = True");
    
    return lines.join("\n");
  }

  generateField(field: DBMLField, table: DBMLTable): string {
    // This method is abstract, use specific generators
    return "";
  }

  private generateDataclassField(field: DBMLField, table: DBMLTable): string {
    const fieldName = this.convertNaming(field.name);
    const fieldType = this.mapDBMLType(field.type, field);
    const isOptional = this.isNullable(field);
    
    let typeAnnotation = fieldType;
    if (isOptional) {
      typeAnnotation = `Optional[${fieldType}]`;
    }
    
    // Add field comment
    const comment = field.note && this.config.addComments ? `  # ${field.note}` : "";
    
    // Handle default values
    if (isOptional || field.default !== undefined) {
      const defaultValue = this.getPythonDefault(field);
      return `    ${fieldName}: ${typeAnnotation} = ${defaultValue}${comment}`;
    }
    
    return `    ${fieldName}: ${typeAnnotation}${comment}`;
  }

  private generateTypedDictField(field: DBMLField, table: DBMLTable): string {
    const fieldName = this.convertNaming(field.name);
    const fieldType = this.mapDBMLType(field.type, field);
    const isOptional = this.isNullable(field);
    
    let typeAnnotation = fieldType;
    if (isOptional) {
      typeAnnotation = `Optional[${fieldType}]`;
    }
    
    // Add field comment
    const comment = field.note && this.config.addComments ? `  # ${field.note}` : "";
    
    return `    ${fieldName}: ${typeAnnotation}${comment}`;
  }

  private generatePydanticField(field: DBMLField, table: DBMLTable): string {
    const fieldName = this.convertNaming(field.name);
    const fieldType = this.mapDBMLType(field.type, field);
    const isOptional = this.isNullable(field);
    
    let typeAnnotation = fieldType;
    if (isOptional) {
      typeAnnotation = `Optional[${fieldType}]`;
    }
    
    // Build Field() arguments
    const fieldArgs: string[] = [];
    
    if (field.default !== undefined) {
      fieldArgs.push(`default=${this.getPythonValue(field.default)}`);
    } else if (isOptional) {
      fieldArgs.push("default=None");
    }
    
    if (field.note) {
      fieldArgs.push(`description="${field.note}"`);
    }
    
    if (field.pk) {
      fieldArgs.push("primary_key=True");
    }
    
    if (field.unique) {
      fieldArgs.push("unique=True");
    }
    
    // Generate field definition
    if (fieldArgs.length > 0) {
      return `    ${fieldName}: ${typeAnnotation} = Field(${fieldArgs.join(", ")})`;
    }
    
    return `    ${fieldName}: ${typeAnnotation}`;
  }

  mapDBMLType(dbmlType: string, field: DBMLField): string {
    const baseType = this.getBaseType(dbmlType);
    const isArray = this.isArrayType(dbmlType);
    
    // Check for enum values
    const enumValues = this.extractEnumValues(dbmlType);
    if (enumValues) {
      if (this.config.enumStyle === "enum") {
        const enumName = `${this.toPascalCase(field.name)}Type`;
        return isArray ? `List[${enumName}]` : enumName;
      } else {
        // Use Literal for union types
        const literalType = `Union[${enumValues.map(v => `"${v}"`).join(", ")}]`;
        return isArray ? `List[${literalType}]` : literalType;
      }
    }

    // Check custom type mappings
    if (this.config.customTypes?.[baseType]) {
      const mappedType = this.config.customTypes[baseType];
      return isArray ? `List[${mappedType}]` : mappedType;
    }

    // Use common type mappings
    const mapping = CommonTypeMappings[baseType];
    if (mapping) {
      const pyType = mapping.py;
      
      // Handle special types
      if (pyType === "datetime" && this.config.dateHandling === "string") {
        return isArray ? "List[str]" : "str";
      }
      
      return isArray ? `List[${pyType}]` : pyType;
    }

    // Default to str for unknown types
    console.warn(`Unknown DBML type: ${dbmlType}, defaulting to 'str'`);
    return isArray ? "List[str]" : "str";
  }

  generateEnum(name: string, values: string[]): string {
    const enumName = this.toPascalCase(name);
    const lines: string[] = [];
    
    lines.push(`class ${enumName}(Enum):`);
    lines.push(`    """Allowed values for ${name}"""`);
    
    for (const value of values) {
      const enumKey = this.toEnumKey(value);
      lines.push(`    ${enumKey} = "${value}"`);
    }
    
    return lines.join("\n");
  }

  private generateAllEnums(schema: DatabaseSchema): string[] {
    const enums: string[] = [];
    const seenEnums = new Set<string>();
    
    for (const table of schema.tables) {
      for (const field of table.fields) {
        const enumValues = this.extractEnumValues(field.type);
        if (enumValues) {
          const enumName = `${this.toPascalCase(field.name)}Type`;
          if (!seenEnums.has(enumName)) {
            seenEnums.add(enumName);
            enums.push(this.generateEnum(`${field.name}Type`, enumValues));
          }
        }
      }
    }
    
    return enums;
  }

  private getPythonDefault(field: DBMLField): string {
    if (field.default !== undefined) {
      return `field(default=${this.getPythonValue(field.default)})`;
    }
    
    if (this.isNullable(field)) {
      return "None";
    }
    
    return "field()";
  }

  private getPythonValue(value: string): string {
    // Handle special values
    if (value.toLowerCase() === "null") return "None";
    if (value.toLowerCase() === "true") return "True";
    if (value.toLowerCase() === "false") return "False";
    
    // Handle numbers
    if (/^-?\d+(\.\d+)?$/.test(value)) return value;
    
    // Handle strings
    return `"${value}"`;
  }

  private toEnumKey(value: string): string {
    // Convert value to valid Python enum key
    return value
      .toUpperCase()
      .replace(/[^A-Z0-9]/g, "_")
      .replace(/^(\d)/, "_$1"); // Prefix with _ if starts with number
  }
}