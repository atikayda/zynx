/**
 * ðŸ¦Ž Zynx Rust Type Generator
 * 
 * Generates Rust struct definitions from DBML schemas
 */

import { TypeGenerator, CommonTypeMappings } from "./base.ts";
import type { DatabaseSchema, DBMLTable, DBMLField, DBMLRef } from "../../types.ts";

export class RustGenerator extends TypeGenerator {
  readonly language = "rust";
  readonly fileExtension = ".rs";
  
  private deriveTraits: string[];
  private useSerde: boolean;
  private useDiesel: boolean;

  constructor(config: any = {}) {
    super({
      caseStyle: "snake_case", // Rust convention for fields
      ...config
    });
    this.deriveTraits = config.deriveTraits || ["Debug", "Clone"];
    this.useSerde = config.useSerde !== false; // Default true
    this.useDiesel = config.useDiesel || false;
    
    // Add serde derives if enabled
    if (this.useSerde && !this.deriveTraits.includes("Serialize")) {
      this.deriveTraits.push("Serialize", "Deserialize");
    }
  }

  override getImports(schema: DatabaseSchema): string[] {
    const imports: string[] = [];
    const useStatements = new Set<string>();
    
    // Check for chrono usage (dates/times)
    const hasDateTimeFields = schema.tables.some(table => 
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["timestamp", "timestamptz", "date", "time", "datetime"].includes(baseType);
      })
    );
    
    if (hasDateTimeFields) {
      useStatements.add("use chrono::{DateTime, NaiveDate, NaiveTime, Utc};");
    }
    
    // Check for UUID usage
    const hasUUIDFields = schema.tables.some(table =>
      table.fields.some(field => this.getBaseType(field.type) === "uuid")
    );
    
    if (hasUUIDFields) {
      useStatements.add("use uuid::Uuid;");
    }
    
    // Check for BigDecimal usage
    const hasDecimalFields = schema.tables.some(table =>
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["decimal", "numeric"].includes(baseType);
      })
    );
    
    if (hasDecimalFields) {
      useStatements.add("use bigdecimal::BigDecimal;");
    }
    
    // Check for JSON usage
    const hasJSONFields = schema.tables.some(table =>
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["json", "jsonb"].includes(baseType);
      })
    );
    
    if (hasJSONFields) {
      useStatements.add("use serde_json::Value as JsonValue;");
    }
    
    // Add serde imports if needed
    if (this.useSerde) {
      useStatements.add("use serde::{Serialize, Deserialize};");
    }
    
    // Add diesel imports if needed
    if (this.useDiesel) {
      useStatements.add("use diesel::prelude::*;");
    }
    
    return Array.from(useStatements).sort();
  }

  override getFileHeader(schema: DatabaseSchema): string {
    const header = [
      "// Generated by Zynx - Database Type Definitions",
      `// Generated at: ${new Date().toISOString()}`,
      "",
      "#![allow(dead_code)]",
      ""
    ];

    return header.join("\n");
  }

  generateSchema(schema: DatabaseSchema): string {
    const types: string[] = [];
    
    // Generate enums first
    const allEnums = this.generateAllEnums(schema);
    if (allEnums.length > 0) {
      types.push(...allEnums);
      types.push(""); // Empty line separator
    }
    
    // Generate structs for each table
    for (const table of schema.tables) {
      types.push(this.generateTable(table));
    }

    // Add module wrapper if namespace is specified
    if (this.config.namespace) {
      return `pub mod ${this.config.namespace} {\n${types.join("\n\n").split("\n").map(line => "    " + line).join("\n")}\n}`;
    }

    return types.join("\n\n");
  }

  generateTable(table: DBMLTable): string {
    const structName = this.toPascalCase(table.name);
    const lines: string[] = [];

    // Add struct documentation
    if (table.note && this.config.addComments) {
      lines.push(`/// ${table.note}`);
    } else {
      lines.push(`/// Represents the ${table.name} table`);
    }

    // Add derive macros
    const derives = this.deriveTraits.join(", ");
    lines.push(`#[derive(${derives})]`);
    
    // Add serde rename if needed
    if (this.useSerde && structName !== table.name) {
      lines.push(`#[serde(rename_all = "snake_case")]`);
    }
    
    // Add diesel table annotation if needed
    if (this.useDiesel) {
      lines.push(`#[diesel(table_name = ${table.name})]`);
    }

    lines.push(`pub struct ${structName} {`);

    // Generate fields
    for (const field of table.fields) {
      const fieldDef = this.generateField(field, table);
      if (fieldDef) {
        fieldDef.split("\n").forEach(line => lines.push(line));
      }
    }

    lines.push(`}`);

    return lines.join("\n");
  }

  generateField(field: DBMLField, table: DBMLTable): string {
    const lines: string[] = [];
    const fieldName = this.convertNaming(field.name);
    const fieldType = this.getRustType(field);
    
    // Add field documentation
    if (field.note && this.config.addComments) {
      lines.push(`    /// ${field.note}`);
    }
    
    // Add serde attributes if needed
    if (this.useSerde) {
      const serdeAttrs: string[] = [];
      
      // Skip serializing None values
      if (this.isNullable(field)) {
        serdeAttrs.push("skip_serializing_if = \"Option::is_none\"");
      }
      
      // Rename field if needed
      if (fieldName !== field.name) {
        serdeAttrs.push(`rename = "${field.name}"`);
      }
      
      // Add default for optional fields
      if (this.isNullable(field) && !field.default) {
        serdeAttrs.push("default");
      }
      
      if (serdeAttrs.length > 0) {
        lines.push(`    #[serde(${serdeAttrs.join(", ")})]`);
      }
    }
    
    // Add diesel column attributes if needed
    if (this.useDiesel) {
      const dieselAttrs: string[] = [];
      
      if (field.pk) {
        dieselAttrs.push("primary_key");
      }
      
      if (fieldName !== field.name) {
        dieselAttrs.push(`column_name = "${field.name}"`);
      }
      
      if (dieselAttrs.length > 0) {
        lines.push(`    #[diesel(${dieselAttrs.join(", ")})]`);
      }
    }
    
    lines.push(`    pub ${fieldName}: ${fieldType},`);
    
    return lines.join("\n");
  }

  private getRustType(field: DBMLField): string {
    const baseType = this.mapDBMLType(field.type, field);
    
    // Handle nullable fields with Option
    if (this.isNullable(field)) {
      return `Option<${baseType}>`;
    }
    
    return baseType;
  }

  mapDBMLType(dbmlType: string, field: DBMLField): string {
    const baseType = this.getBaseType(dbmlType);
    const isArray = this.isArrayType(dbmlType);
    
    // Check for enum values
    const enumValues = this.extractEnumValues(dbmlType);
    if (enumValues) {
      const enumName = `${this.toPascalCase(field.name)}Type`;
      return isArray ? `Vec<${enumName}>` : enumName;
    }

    // Check custom type mappings
    if (this.config.customTypes?.[baseType]) {
      const mappedType = this.config.customTypes[baseType];
      return isArray ? `Vec<${mappedType}>` : mappedType;
    }

    // Use common type mappings
    const mapping = CommonTypeMappings[baseType];
    if (mapping) {
      const rustType = mapping.rust;
      
      // Handle date types based on config
      if (this.config.dateHandling === "string" && rustType.includes("Date") || rustType.includes("Time")) {
        return isArray ? "Vec<String>" : "String";
      }
      
      // Handle JSON type naming
      if (rustType === "serde_json::Value") {
        return isArray ? "Vec<JsonValue>" : "JsonValue";
      }
      
      return isArray ? `Vec<${rustType}>` : rustType;
    }

    // Default to String for unknown types
    console.warn(`Unknown DBML type: ${dbmlType}, defaulting to 'String'`);
    return isArray ? "Vec<String>" : "String";
  }

  generateEnum(name: string, values: string[]): string {
    const enumName = this.toPascalCase(name);
    const lines: string[] = [];
    
    lines.push(`/// Allowed values for ${name}`);
    
    // Add derive macros for enum
    const enumDerives = ["Debug", "Clone", "PartialEq", "Eq"];
    if (this.useSerde) {
      enumDerives.push("Serialize", "Deserialize");
    }
    lines.push(`#[derive(${enumDerives.join(", ")})]`);
    
    if (this.useSerde) {
      lines.push(`#[serde(rename_all = "snake_case")]`);
    }
    
    lines.push(`pub enum ${enumName} {`);
    
    for (const value of values) {
      const variantName = this.toEnumVariant(value);
      
      // Add serde rename if variant name differs from value
      if (this.useSerde && variantName !== value) {
        lines.push(`    #[serde(rename = "${value}")]`);
      }
      
      lines.push(`    ${variantName},`);
    }
    
    lines.push(`}`);
    
    // Add Display implementation
    lines.push("");
    lines.push(`impl std::fmt::Display for ${enumName} {`);
    lines.push(`    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {`);
    lines.push(`        match self {`);
    
    for (const value of values) {
      const variantName = this.toEnumVariant(value);
      lines.push(`            ${enumName}::${variantName} => write!(f, "${value}"),`);
    }
    
    lines.push(`        }`);
    lines.push(`    }`);
    lines.push(`}`);
    
    // Add FromStr implementation
    lines.push("");
    lines.push(`impl std::str::FromStr for ${enumName} {`);
    lines.push(`    type Err = String;`);
    lines.push("");
    lines.push(`    fn from_str(s: &str) -> Result<Self, Self::Err> {`);
    lines.push(`        match s {`);
    
    for (const value of values) {
      const variantName = this.toEnumVariant(value);
      lines.push(`            "${value}" => Ok(${enumName}::${variantName}),`);
    }
    
    lines.push(`            _ => Err(format!("Invalid ${enumName}: {}", s)),`);
    lines.push(`        }`);
    lines.push(`    }`);
    lines.push(`}`);
    
    return lines.join("\n");
  }

  private generateAllEnums(schema: DatabaseSchema): string[] {
    const enums: string[] = [];
    const seenEnums = new Set<string>();
    
    for (const table of schema.tables) {
      for (const field of table.fields) {
        const enumValues = this.extractEnumValues(field.type);
        if (enumValues) {
          const enumName = `${this.toPascalCase(field.name)}Type`;
          if (!seenEnums.has(enumName)) {
            seenEnums.add(enumName);
            enums.push(this.generateEnum(`${field.name}Type`, enumValues));
          }
        }
      }
    }
    
    return enums;
  }

  private toEnumVariant(value: string): string {
    // Convert value to valid Rust enum variant
    return this.toPascalCase(
      value
        .replace(/[^a-zA-Z0-9]/g, "_")
        .replace(/^(\d)/, "_$1") // Prefix with _ if starts with number
    );
  }
}