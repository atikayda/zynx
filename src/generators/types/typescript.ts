/**
 * ðŸ¦Ž Zynx TypeScript Type Generator
 * 
 * Generates TypeScript type definitions from DBML schemas
 */

import { TypeGenerator, CommonTypeMappings } from "./base.ts";
import type { DatabaseSchema, DBMLTable, DBMLField, DBMLRef } from "../../types.ts";

export class TypeScriptGenerator extends TypeGenerator {
  readonly language = "typescript";
  readonly fileExtension = ".ts";

  override getImports(schema: DatabaseSchema): string[] {
    const imports: string[] = [];
    
    // Check if we need Date type
    if (this.config.dateHandling === "Date") {
      const hasDateFields = schema.tables.some(table => 
        table.fields.some(field => {
          const baseType = this.getBaseType(field.type);
          return ["timestamp", "timestamptz", "date", "datetime"].includes(baseType);
        })
      );
      // TypeScript Date is built-in, no import needed
    }
    
    // Check if we need Buffer type  
    const hasBufferFields = schema.tables.some(table =>
      table.fields.some(field => {
        const baseType = this.getBaseType(field.type);
        return ["bytea", "blob"].includes(baseType);
      })
    );
    
    if (hasBufferFields) {
      // Node.js Buffer type is global, no import needed in TypeScript
    }
    
    return imports;
  }

  override getFileHeader(schema: DatabaseSchema): string {
    const header = [
      "/**",
      " * Generated by Zynx - Database Type Definitions",
      ` * Generated at: ${new Date().toISOString()}`,
      " */",
      ""
    ];

    if (this.config.namespace) {
      header.push(`export namespace ${this.config.namespace} {`);
    }

    return header.join("\n");
  }

  override getFileFooter(): string {
    if (this.config.namespace) {
      return "}";
    }
    return "";
  }

  generateSchema(schema: DatabaseSchema): string {
    const types: string[] = [];
    
    // Generate types for each table
    for (const table of schema.tables) {
      types.push(this.generateTable(table));
    }

    // Generate relationship types if enabled
    if (this.config.includeRelationships && schema.refs.length > 0) {
      types.push(this.generateRelationshipTypes(schema));
    }

    const indent = this.config.namespace ? this.getIndent() : "";
    return types.map(t => t.split("\n").map(line => indent + line).join("\n")).join("\n\n");
  }

  generateTable(table: DBMLTable): string {
    const typeName = this.toPascalCase(table.name);
    const lines: string[] = [];

    // Add table comment if available
    if (table.note && this.config.addComments) {
      lines.push(`/**`);
      lines.push(` * ${table.note}`);
      lines.push(` */`);
    }

    lines.push(`export interface ${typeName} {`);

    // Generate fields
    for (const field of table.fields) {
      const fieldDef = this.generateField(field, table);
      if (fieldDef) {
        lines.push(fieldDef);
      }
    }

    lines.push(`}`);

    // Generate enum types for fields with enum constraints
    const enumTypes = this.generateTableEnums(table);
    if (enumTypes.length > 0) {
      lines.push("");
      lines.push(...enumTypes);
    }

    return lines.join("\n");
  }

  generateField(field: DBMLField, table: DBMLTable): string {
    const lines: string[] = [];
    const indent = this.getIndent();
    
    // Add field comment
    if (field.note && this.config.addComments) {
      lines.push(`${indent}/** ${field.note} */`);
    }

    // Generate field name and type
    const fieldName = this.convertNaming(field.name);
    const fieldType = this.mapDBMLType(field.type, field);
    const isOptional = this.isNullable(field) && this.config.optionalHandling !== "nullable";
    const optionalMark = isOptional ? "?" : "";
    const nullableType = this.isNullable(field) && this.config.optionalHandling !== "optional" 
      ? ` | null` 
      : "";

    lines.push(`${indent}${fieldName}${optionalMark}: ${fieldType}${nullableType};`);

    return lines.join("\n");
  }

  mapDBMLType(dbmlType: string, field: DBMLField): string {
    const baseType = this.getBaseType(dbmlType);
    const isArray = this.isArrayType(dbmlType);
    
    // Check for enum values
    const enumValues = this.extractEnumValues(dbmlType);
    if (enumValues) {
      const enumName = `${this.toPascalCase(field.name)}Type`;
      return isArray ? `${enumName}[]` : enumName;
    }

    // Check custom type mappings
    if (this.config.customTypes?.[baseType]) {
      const mappedType = this.config.customTypes[baseType];
      return isArray ? `${mappedType}[]` : mappedType;
    }

    // Use common type mappings
    const mapping = CommonTypeMappings[baseType];
    if (mapping) {
      const tsType = mapping.ts;
      // Handle date types based on config
      if (this.config.dateHandling === "string" && tsType === "Date") {
        return isArray ? "string[]" : "string";
      }
      return isArray ? `${tsType}[]` : tsType;
    }

    // Default to any for unknown types
    console.warn(`Unknown DBML type: ${dbmlType}, defaulting to 'any'`);
    return isArray ? "any[]" : "any";
  }

  generateEnum(name: string, values: string[]): string {
    const enumName = this.toPascalCase(name);
    
    if (this.config.enumStyle === "enum") {
      const lines = [`export enum ${enumName} {`];
      for (const value of values) {
        const enumKey = this.toEnumKey(value);
        lines.push(`${this.getIndent()}${enumKey} = "${value}",`);
      }
      lines.push(`}`);
      return lines.join("\n");
    } else {
      // Union type
      const unionValues = values.map(v => `"${v}"`).join(" | ");
      return `export type ${enumName} = ${unionValues};`;
    }
  }

  private generateTableEnums(table: DBMLTable): string[] {
    const enums: string[] = [];
    
    for (const field of table.fields) {
      const enumValues = this.extractEnumValues(field.type);
      if (enumValues) {
        const enumName = `${this.toPascalCase(field.name)}Type`;
        enums.push(this.generateEnum(enumName, enumValues));
      }
    }
    
    return enums;
  }

  private generateRelationshipTypes(schema: DatabaseSchema): string {
    const lines: string[] = [];
    
    lines.push("/**");
    lines.push(" * Database Relationships");
    lines.push(" */");
    lines.push("export interface DatabaseRelationships {");
    
    for (const ref of schema.refs) {
      const fromTable = this.toPascalCase(ref.from.table);
      const toTable = this.toPascalCase(ref.to.table);
      const relationName = ref.name || `${fromTable}To${toTable}`;
      
      lines.push(`${this.getIndent()}${this.toCamelCase(relationName)}: {`);
      lines.push(`${this.getIndent(2)}from: keyof ${fromTable};`);
      lines.push(`${this.getIndent(2)}to: keyof ${toTable};`);
      lines.push(`${this.getIndent(2)}type: "${ref.type}";`);
      if (ref.onDelete) {
        lines.push(`${this.getIndent(2)}onDelete: "${ref.onDelete}";`);
      }
      if (ref.onUpdate) {
        lines.push(`${this.getIndent(2)}onUpdate: "${ref.onUpdate}";`);
      }
      lines.push(`${this.getIndent()}};`);
    }
    
    lines.push("}");
    
    return lines.join("\n");
  }

  private toEnumKey(value: string): string {
    // Convert value to valid TypeScript enum key
    return value
      .toUpperCase()
      .replace(/[^A-Z0-9]/g, "_")
      .replace(/^(\d)/, "_$1"); // Prefix with _ if starts with number
  }
}